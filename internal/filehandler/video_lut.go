package filehandler

// video_lut.go provides color Look-Up Table (LUT) computation and application
// for propagating frame enhancements across video frame groups.
// See DDR-032: Multi-Step Frame-Based Video Enhancement Pipeline.

import (
	"bytes"
	"context"
	"fmt"
	"image"
	"image/jpeg"
	"math"
	"os"
	"os/exec"
	"strings"

	"github.com/rs/zerolog/log"
)

// lutSize is the number of entries per channel in the 3D LUT.
const lutSize = 64

// ComputeColorLUT computes a 3D color Look-Up Table that maps colors from
// the original image to the enhanced image. This LUT can then be applied
// to all frames in a group to propagate the enhancement consistently.
//
// The LUT uses 64 entries per channel (64x64x64 = 262,144 entries) for
// smooth color mapping with minimal banding.
//
// Parameters:
//   - originalPath: path to the original representative frame
//   - enhancedPath: path to the enhanced representative frame
//
// Returns a .cube format LUT string that can be used with ffmpeg's lut3d filter.
func ComputeColorLUT(originalPath, enhancedPath string) (string, error) {
	log.Debug().
		Str("original", originalPath).
		Str("enhanced", enhancedPath).
		Msg("Computing color LUT from original→enhanced mapping")

	origFile, err := os.Open(originalPath)
	if err != nil {
		return "", fmt.Errorf("failed to open original frame: %w", err)
	}
	defer origFile.Close()

	origImg, err := jpeg.Decode(origFile)
	if err != nil {
		return "", fmt.Errorf("failed to decode original frame: %w", err)
	}

	enhFile, err := os.Open(enhancedPath)
	if err != nil {
		return "", fmt.Errorf("failed to open enhanced frame: %w", err)
	}
	defer enhFile.Close()

	enhImg, err := jpeg.Decode(enhFile)
	if err != nil {
		return "", fmt.Errorf("failed to decode enhanced frame: %w", err)
	}

	return computeLUTFromImages(origImg, enhImg)
}

// ComputeColorLUTFromData computes a 3D color LUT from raw image data.
func ComputeColorLUTFromData(originalData, enhancedData []byte) (string, error) {
	origImg, err := jpeg.Decode(bytes.NewReader(originalData))
	if err != nil {
		return "", fmt.Errorf("failed to decode original image: %w", err)
	}

	enhImg, err := jpeg.Decode(bytes.NewReader(enhancedData))
	if err != nil {
		return "", fmt.Errorf("failed to decode enhanced image: %w", err)
	}

	return computeLUTFromImages(origImg, enhImg)
}

// computeLUTFromImages builds a .cube format 3D LUT by sampling the color
// transformation between original and enhanced images.
func computeLUTFromImages(origImg, enhImg image.Image) (string, error) {
	origBounds := origImg.Bounds()
	enhBounds := enhImg.Bounds()

	// Images may have different dimensions (Gemini may resize).
	// We sample from both using normalized coordinates.
	origW := origBounds.Dx()
	origH := origBounds.Dy()
	enhW := enhBounds.Dx()
	enhH := enhBounds.Dy()

	if origW == 0 || origH == 0 || enhW == 0 || enhH == 0 {
		return "", fmt.Errorf("invalid image dimensions: orig=%dx%d, enh=%dx%d", origW, origH, enhW, enhH)
	}

	// Build accumulation buffers for the LUT
	// For each (r,g,b) bin, accumulate the sum of enhanced colors and count
	type lutEntry struct {
		sumR, sumG, sumB float64
		count            int
	}
	lut := make([]lutEntry, lutSize*lutSize*lutSize)

	binSize := 256.0 / float64(lutSize)

	// Sample pixels from both images at corresponding normalized positions
	sampleStep := 2 // Sample every 2nd pixel for speed
	for y := 0; y < origH; y += sampleStep {
		// Map y to enhanced image coordinates
		enhY := y * enhH / origH
		if enhY >= enhH {
			enhY = enhH - 1
		}

		for x := 0; x < origW; x += sampleStep {
			// Map x to enhanced image coordinates
			enhX := x * enhW / origW
			if enhX >= enhW {
				enhX = enhW - 1
			}

			// Get original pixel color
			oR, oG, oB, _ := origImg.At(origBounds.Min.X+x, origBounds.Min.Y+y).RGBA()
			// Get enhanced pixel color at corresponding position
			eR, eG, eB, _ := enhImg.At(enhBounds.Min.X+enhX, enhBounds.Min.Y+enhY).RGBA()

			// Scale from 16-bit to 8-bit
			oR8 := float64(oR >> 8)
			oG8 := float64(oG >> 8)
			oB8 := float64(oB >> 8)
			eR8 := float64(eR >> 8)
			eG8 := float64(eG >> 8)
			eB8 := float64(eB >> 8)

			// Map to LUT bin
			rBin := int(oR8 / binSize)
			gBin := int(oG8 / binSize)
			bBin := int(oB8 / binSize)
			if rBin >= lutSize {
				rBin = lutSize - 1
			}
			if gBin >= lutSize {
				gBin = lutSize - 1
			}
			if bBin >= lutSize {
				bBin = lutSize - 1
			}

			idx := rBin*lutSize*lutSize + gBin*lutSize + bBin
			lut[idx].sumR += eR8
			lut[idx].sumG += eG8
			lut[idx].sumB += eB8
			lut[idx].count++
		}
	}

	// Generate .cube file content
	// .cube format: https://resolve.cafe/developers/luts/
	var sb strings.Builder
	sb.WriteString("# Generated by ai-social-media-helper (DDR-032)\n")
	sb.WriteString("TITLE \"Video Enhancement LUT\"\n")
	sb.WriteString(fmt.Sprintf("LUT_3D_SIZE %d\n", lutSize))
	sb.WriteString("\n")

	// Write LUT entries: iterate B (fastest), G, R (slowest)
	for rBin := 0; rBin < lutSize; rBin++ {
		for gBin := 0; gBin < lutSize; gBin++ {
			for bBin := 0; bBin < lutSize; bBin++ {
				idx := rBin*lutSize*lutSize + gBin*lutSize + bBin
				entry := lut[idx]

				var outR, outG, outB float64
				if entry.count > 0 {
					// Average the enhanced colors for this bin
					outR = entry.sumR / float64(entry.count) / 255.0
					outG = entry.sumG / float64(entry.count) / 255.0
					outB = entry.sumB / float64(entry.count) / 255.0
				} else {
					// No samples for this bin — use identity mapping
					outR = float64(rBin) / float64(lutSize-1)
					outG = float64(gBin) / float64(lutSize-1)
					outB = float64(bBin) / float64(lutSize-1)
				}

				// Clamp to [0, 1]
				outR = math.Max(0, math.Min(1, outR))
				outG = math.Max(0, math.Min(1, outG))
				outB = math.Max(0, math.Min(1, outB))

				sb.WriteString(fmt.Sprintf("%.6f %.6f %.6f\n", outR, outG, outB))
			}
		}
	}

	return sb.String(), nil
}

// ApplyLUTToFrames applies a .cube format 3D LUT to all frames in a directory
// using ffmpeg's lut3d filter. Enhanced frames are written to the output directory.
//
// Parameters:
//   - framePaths: paths to the source frames to apply the LUT to
//   - lutContent: the .cube format LUT string
//   - outputDir: directory where LUT-applied frames will be written
func ApplyLUTToFrames(ctx context.Context, framePaths []string, lutContent string, outputDir string) error {
	if len(framePaths) == 0 {
		return nil
	}

	ffmpegPath, err := exec.LookPath("ffmpeg")
	if err != nil {
		return fmt.Errorf("ffmpeg not found: LUT application requires ffmpeg: %w", err)
	}

	// Write LUT to temporary file
	lutFile, err := os.CreateTemp("", "enhancement-lut-*.cube")
	if err != nil {
		return fmt.Errorf("failed to create temp LUT file: %w", err)
	}
	lutPath := lutFile.Name()
	defer os.Remove(lutPath)

	if _, err := lutFile.WriteString(lutContent); err != nil {
		lutFile.Close()
		return fmt.Errorf("failed to write LUT file: %w", err)
	}
	lutFile.Close()

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	log.Info().
		Int("frame_count", len(framePaths)).
		Str("output_dir", outputDir).
		Msg("Applying color LUT to frames")

	// Apply LUT to each frame using ffmpeg
	for i, framePath := range framePaths {
		outputPath := fmt.Sprintf("%s/frame_%06d.jpg", outputDir, i+1)

		cmd := exec.CommandContext(ctx, ffmpegPath,
			"-i", framePath,
			"-vf", fmt.Sprintf("lut3d='%s'", lutPath),
			"-qscale:v", "2",
			"-y", outputPath,
		)

		output, err := cmd.CombinedOutput()
		if err != nil {
			log.Warn().
				Err(err).
				Int("frame", i).
				Str("output", string(output)).
				Msg("Failed to apply LUT to frame, copying original")

			// Fallback: copy original frame
			data, readErr := os.ReadFile(framePath)
			if readErr != nil {
				return fmt.Errorf("failed to apply LUT and read fallback for frame %d: %w", i, readErr)
			}
			if writeErr := os.WriteFile(outputPath, data, 0o644); writeErr != nil {
				return fmt.Errorf("failed to write fallback frame %d: %w", i, writeErr)
			}
		}
	}

	log.Info().
		Int("frame_count", len(framePaths)).
		Msg("Color LUT applied to all frames")

	return nil
}
